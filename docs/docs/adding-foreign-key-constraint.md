---
id: adding-foreign-key-constraint
title: adding-foreign-key-constraint
---

## problem

Adding a foreign key constraint requires a table scan and a `SHARE ROW EXCLUSIVE` lock on both tables, which blocks writes to each table.

This means no writes will be allowed to either table while the table you're altering is scanned to validate the constraint.

## solution

To prevent blocking writes to tables, add the constraint as `NOT VALID` in one transaction, then `VALIDATE CONSTRAINT` in another.

While `NOT VALID` prevents row updates while running, it commits instantly if it can get a lock (see ["Safety requirements"](./safe_migrations.md#safety-requirements)). `VALIDATE CONSTRAINT` allows row updates while it scans
the table.

See ["How not valid constraints work"](constraint-missing-not-valid.md#how-not-valid-validate-works) for more information on adding constraints as `NOT VALID`.

### adding constraint to existing table

Instead of:

```sql
-- blocks writes to "email" and "user" while Postgres checks rows in "email" have user_id mapping to "user".id (slow)
ALTER TABLE "email" ADD CONSTRAINT "fk_user"
    FOREIGN KEY ("user_id") REFERENCES "user" ("id");
```

Use:

```sql
-- blocks writes to "email" and "user" while Postgres updates table schema (fast)
ALTER TABLE "email" ADD CONSTRAINT "fk_user"
    FOREIGN KEY ("user_id") REFERENCES "user" ("id") NOT VALID;
-- non-blocking while existing rows are checked.
ALTER TABLE "email" VALIDATE CONSTRAINT "fk_user";
```

Add the foreign key constraint as `NOT VALID` to prevent locking the `"email"` and `"user"` tables while "email" rows are checked against "user".

Run `VALIDATE CONSTRAINT` to scan the `"email"` table in the background while reads and writes continue.

### adding constraint to new table

Both of these examples have the same amount of locking. Since the newly created table has no rows, you don't need to add a foreign key with `NOT VALID`. 

Adding foreign key constraint in `create table` statement.

```sql
-- blocks writes to "user" while Postgres updates table schema.
CREATE TABLE email (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    user_id BIGINT,
    email TEXT,
    PRIMARY KEY(id),
    CONSTRAINT fk_user
        FOREIGN KEY ("user_id")
        REFERENCES "user" ("id")
);
```

Using `not valid...validate`:

```sql
-- no references to lock.
CREATE TABLE email (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    user_id BIGINT,
    email TEXT,
    PRIMARY KEY(id)
);

-- blocks writes to "email" and "user" while Postgres updates table schema (fast)
ALTER TABLE "email" ADD CONSTRAINT "fk_user"
    FOREIGN KEY ("user_id") REFERENCES "user" ("id") NOT VALID;
-- non-blocking while existing rows are checked.
ALTER TABLE "email" VALIDATE CONSTRAINT "fk_user";
```


## solution for alembic and sqlalchemy

### adding constraint to existing table ###

Instead of:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    ...
    new_model_id = sa.Column(sa.BigInteger, sa.ForeignKey("new_alembic_validate_migration.id"))
    ...


class NewAlembicValidateMigration(BaseModel):
    __tablename__ = "new_alembic_validate_migration"

    id = sa.Column(sa.BigInteger, primary_key=True, autoincrement=True)
    ...
```

```python
# migrations/*.py
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("alembic_validate_migration", sa.Column("new_model_id", sa.BigInteger(), nullable=True))
    op.create_foreign_key(None, "alembic_validate_migration", "new_alembic_validate_migration", ["new_model_id"], ["id"])
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, "alembic_validate_migration", type_="foreignkey")
    op.drop_column("alembic_validate_migration", "new_model_id")
    # ### end Alembic commands ###
```

Use:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    ...
    new_model_id = sa.Column(
        sa.BigInteger,
        sa.ForeignKey(
            "new_alembic_validate_migration.id",
            name="fk_alembic_validate_migration_new_model_id",
        )
    )
    ...


class NewAlembicValidateMigration(BaseModel):
    __tablename__ = "new_alembic_validate_migration"

    id = sa.Column(sa.BigInteger, primary_key=True, autoincrement=True)
    ...
```

```python
# migrations/*.py
# First migration
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("alembic_validate_migration", sa.Column("new_model_id", sa.BigInteger(), nullable=True))
    op.create_foreign_key(
        "fk_alembic_validate_migration_new_model_id", 
        "alembic_validate_migration", 
        "new_alembic_validate_migration", 
        ["new_model_id"], 
        ["id"], 
        postgresql_not_valid=True
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(
        "fk_alembic_validate_migration_new_model_id", 
        "alembic_validate_migration", 
        type_="foreignkey"
    )
    op.drop_column("alembic_validate_migration", "new_model_id")
    # ### end Alembic commands ###
```

```python
# migrations/*.py
# Second migration
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute(
        sa.text(
            """ALTER TABLE alembic_validate_migration VALIDATE CONSTRAINT fk_alembic_validate_migration_new_model_id"""
        ),
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
```


### adding constraint to new table

Instead of:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    ...


class NewTable(BaseModel):
    __tablename__ = "new_table"

    id = sa.Column(sa.BigInteger, primary_key=True, autoincrement=True)

    alembic_validate_migration_id = sa.Column(sa.BigInteger, sa.ForeignKey("alembic_validate_migration.id"))
```

```python
# migrations/*.py
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table("new_table",
    sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column("alembic_validate_migration_id", sa.BigInteger(), nullable=True),
    sa.ForeignKeyConstraint(["alembic_validate_migration_id"], ["alembic_validate_migration.id"], ),
    sa.PrimaryKeyConstraint("id")
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("new_table")
    # ### end Alembic commands ###
```

Use:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    ...


class NewTable(BaseModel):
    __tablename__ = "new_table"

    id = sa.Column(sa.BigInteger, primary_key=True, autoincrement=True)

    alembic_validate_migration_id = sa.Column(
        sa.BigInteger, 
        sa.ForeignKey(
            "alembic_validate_migration.id",
            name="fk_alembic_validate_migration_id"
        )
    )
```

```python
# migrations/*.py
# First migration
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table("new_table",
    sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column("alembic_validate_migration_id", sa.BigInteger(), nullable=True),
    sa.PrimaryKeyConstraint("id")
    )
    op.create_foreign_key(
        "fk_alembic_validate_migration_id",
        "new_table",
        "alembic_validate_migration",
        ["alembic_validate_migration_id"],
        ["id"],
        postgresql_not_valid=True
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("new_table")
    # ### end Alembic commands ###
```

```python
# migrations/*.py
# Second migration
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute(
        sa.text(
            """ALTER TABLE new_table VALIDATE CONSTRAINT fk_alembic_validate_migration_id"""
        ),
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
```

## links

- https://travisofthenorth.com/blog/2017/2/2/postgres-adding-foreign-keys-with-zero-downtime