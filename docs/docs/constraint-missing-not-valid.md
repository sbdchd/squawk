---
id: constraint-missing-not-valid
title: constraint-missing-not-valid
---

## problem

By default new constraints require a table scan and block writes to the table
while that scan occurs.

## solution

Using `NOT VALID` with a later `VALIDATE CONSTRAINT`
call prevents the table scan and results in the validation step only requiring a
`SHARE UPDATE EXCLUSIVE` lock.

<https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-NOTES>

Instead of:

```sql
ALTER TABLE "accounts" ADD CONSTRAINT "positive_balance" CHECK ("balance" >= 0);
```

Use:

```sql
ALTER TABLE "accounts" ADD CONSTRAINT "positive_balance" CHECK ("balance" >= 0) NOT VALID;
ALTER TABLE accounts VALIDATE CONSTRAINT positive_balance;
```

## solution for alembic and sqlalchemy

Instead of:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    __table_args__ = (
        sa.CheckConstraint(
            '"some_field_with_check" > 0',
            name="ck_alembic_validate_migration_some_field_with_check"
        ),
    )
    ...
```

```python
# migrations/*.py
from alembic import op


def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_check_constraint(
        constraint_name="ck_alembic_validate_migration_some_field_with_check",
        table_name="alembic_validate_migration",
        condition='"some_field_with_check" > 0',
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(
        constraint_name="ck_alembic_validate_migration_some_field_with_check",
        table_name="alembic_validate_migration",
        type_="check"
    )
    # ### end Alembic commands ###
```

Use:

```python
# models.py
import sqlalchemy as sa

class AlembicValidateMigration(BaseModel):
    __tablename__ = "alembic_validate_migration"
    __table_args__ = (
        sa.CheckConstraint(
            '"some_field_with_check" > 0',
            name="ck_alembic_validate_migration_some_field_with_check"
        ),
    )
    ...
```

```python
# migrations/*.py
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_check_constraint(
        constraint_name="ck_alembic_validate_migration_some_field_with_check",
        table_name="alembic_validate_migration",
        condition='"some_field_with_check" > 0',
        postgresql_not_valid=True,
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(
        constraint_name="ck_alembic_validate_migration_some_field_with_check",
        table_name="alembic_validate_migration",
        type_="check"
    )
    # ### end Alembic commands ###
```

```python
# migrations/*.py
import sqlalchemy as sa
from alembic import op

def schema_upgrades():
    """schema upgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute(
        sa.text(
            """ALTER TABLE alembic_validate_migration VALIDATE CONSTRAINT ck_alembic_validate_migration_some_field_with_check"""
        ),
    )
    # ### end Alembic commands ###


def schema_downgrades():
    """schema downgrade migrations go here."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
```

## how "not valid, validate" works

When we add this constraint, writes to the `accounts` table will be blocked while the table is scanned to verify all `positive_balance` column entries match the check constraint `"balance" >= 0`.


```sql
ALTER TABLE "accounts" ADD CONSTRAINT "positive_balance" CHECK ("balance" >= 0);
```

By adding the check constraint as `NOT VALID`, existing columns are not checked against the constraint, only new rows or updates to existing rows. This constraint can be applied without blocking writes.

Afterwards, we can call `VALIDATE CONSTRAINT` to verify that the existing `positive_balance` entries meet the constraint. This will require a table scan of `accounts`, but writes will not be blocked.

Postgres doesn't need to block writes for `VALIDATE CONSTRAINT` since Postgres will prevent any new rows or modifications from violating the constraint. So Postgres can scan `accounts` and depend on other transactions enforcing the constraint in concurrent updates.
